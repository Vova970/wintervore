import os
import sqlite3
from datetime import datetime
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    filters
)
import logging
import threading
import time

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–æ–≤
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –°–æ—Å—Ç–æ—è–Ω–∏—è
LANGUAGE, TRADE, ADMIN_MAIN, ADMIN_STATS, ADMIN_REQUESTS, ADMIN_BROADCAST, ADMIN_BROADCAST_CONFIRM = range(7)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
ADMIN_IDS = [8126533622]  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à ID
TOKEN = os.getenv('TELEGRAM_BOT_TOKEN') or '7715353196:AAEvyhRGpqFrUrL_eC9HMozwn9IdyIWwBM4'
DB_FILE = 'bot_database.db'
BROADCAST_LOCK = threading.Lock()

class Database:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(Database, cls).__new__(cls)
                    cls._instance._initialize_db()
        return cls._instance

    def _initialize_db(self):
        self.conn = sqlite3.connect(DB_FILE, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row
        self._create_tables()

    def _create_tables(self):
        cursor = self.conn.cursor()
        
        cursor.execute('''CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            first_name TEXT,
            last_name TEXT,
            lang TEXT DEFAULT 'ru',
            blocked INTEGER DEFAULT 0,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )''')
        
        cursor.execute('''CREATE TABLE IF NOT EXISTS requests (
            request_id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            link TEXT,
            summer_id TEXT,
            status TEXT DEFAULT 'pending',
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY(user_id) REFERENCES users(user_id)
        )''')
        
        cursor.execute('''CREATE TABLE IF NOT EXISTS broadcast_history (
            broadcast_id INTEGER PRIMARY KEY AUTOINCREMENT,
            admin_id INTEGER,
            message_text TEXT,
            total_users INTEGER,
            success_count INTEGER,
            failed_count INTEGER,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP
        )''')
        
        self.conn.commit()

    def get_user(self, user_id):
        cursor = self.conn.cursor()
        cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
        return cursor.fetchone()

    def add_user(self, user_id, username, first_name, last_name, lang):
        cursor = self.conn.cursor()
        cursor.execute('''INSERT OR IGNORE INTO users (user_id, username, first_name, last_name, lang) 
        VALUES (?, ?, ?, ?, ?)''', (user_id, username, first_name, last_name, lang))
        self.conn.commit()

    def update_user_lang(self, user_id, lang):
        cursor = self.conn.cursor()
        cursor.execute('UPDATE users SET lang = ? WHERE user_id = ?', (lang, user_id))
        self.conn.commit()

    def add_request(self, user_id, link, summer_id):
        cursor = self.conn.cursor()
        cursor.execute('''INSERT INTO requests (user_id, link, summer_id) 
        VALUES (?, ?, ?)''', (user_id, link, summer_id))
        request_id = cursor.lastrowid
        self.conn.commit()
        return request_id

    def get_pending_requests(self, page=0, per_page=10):
        cursor = self.conn.cursor()
        cursor.execute('''SELECT r.request_id, r.created_at, u.user_id, u.username 
        FROM requests r
        JOIN users u ON r.user_id = u.user_id
        WHERE r.status = 'pending'
        ORDER BY r.created_at DESC
        LIMIT ? OFFSET ?''', (per_page, page * per_page))
        return cursor.fetchall()

    def get_request(self, request_id):
        cursor = self.conn.cursor()
        cursor.execute('''SELECT r.*, u.username 
        FROM requests r
        JOIN users u ON r.user_id = u.user_id
        WHERE r.request_id = ?''', (request_id,))
        return cursor.fetchone()

    def update_request_status(self, request_id, status):
        cursor = self.conn.cursor()
        cursor.execute('UPDATE requests SET status = ? WHERE request_id = ?', (status, request_id))
        self.conn.commit()

    def get_stats(self):
        cursor = self.conn.cursor()
        
        cursor.execute('''SELECT COUNT(*) FROM users 
        WHERE date(created_at) = date('now') AND blocked = 0''')
        today = cursor.fetchone()[0]
        
        cursor.execute('''SELECT COUNT(*) FROM users 
        WHERE date(created_at) = date('now', '-1 day') AND blocked = 0''')
        yesterday = cursor.fetchone()[0]
        
        cursor.execute('SELECT COUNT(*) FROM users WHERE blocked = 0')
        total = cursor.fetchone()[0]
        
        return today, yesterday, total

    def get_all_active_users(self):
        cursor = self.conn.cursor()
        cursor.execute('SELECT user_id FROM users WHERE blocked = 0')
        return [row[0] for row in cursor.fetchall()]

    def mark_blocked_users(self, user_ids):
        cursor = self.conn.cursor()
        cursor.executemany('UPDATE users SET blocked = 1 WHERE user_id = ?', [(uid,) for uid in user_ids])
        self.conn.commit()
        return cursor.rowcount

    def add_broadcast_record(self, admin_id, message_text, total_users, success_count, failed_count):
        cursor = self.conn.cursor()
        cursor.execute('''INSERT INTO broadcast_history 
        (admin_id, message_text, total_users, success_count, failed_count)
        VALUES (?, ?, ?, ?, ?)''', (admin_id, message_text, total_users, success_count, failed_count))
        self.conn.commit()
        return cursor.lastrowid

    def close(self):
        self.conn.close()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
db = Database()

async def send_message_safe(bot, chat_id, text, parse_mode=None, reply_markup=None):
    try:
        await bot.send_message(
            chat_id=chat_id,
            text=text,
            parse_mode=parse_mode,
            reply_markup=reply_markup
        )
        return True
    except Exception as e:
        logger.error(f"Failed to send message to {chat_id}: {e}")
        return False

def get_main_menu_text(lang):
    if lang == 'ru':
        return (
            "ü§ñ –≠—Ç–æ—Ç –±–æ—Ç —Å–æ–∑–¥–∞–Ω –¥–ª—è *–±–µ—Å–ø–ª–∞—Ç–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∞*\\.\n\n"
            "–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å *–ø–æ–ª–µ–∑–Ω—ã–π —Ü–∏—Ñ—Ä–æ–≤–æ–π —Ç–æ–≤–∞—Ä* –∏–ª–∏ *–≥—Ä—É–ø–ø–∞ –≤ Telegram*, –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω—ë–º –ø—Ä—è–º–æ –∑–¥–µ—Å—å\\.\n\n"
            "–ï—Å–ª–∏ –≤–∞—à —Ç–æ–≤–∞—Ä –æ–∫–∞–∂–µ—Ç—Å—è *—Ä–∞–±–æ—á–∏–º –∏ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–º*, –≤—ã –ø–æ–ª—É—á–∏—Ç–µ *–≤–∞–ª—é—Ç—É –≤–Ω—É—Ç—Ä–∏ –±–æ—Ç–∞*\\. –†–∞–∑–º–µ—Ä –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, *–Ω–∞—Å–∫–æ–ª—å–∫–æ —Ü–µ–Ω–Ω—ã–º –∏ –ø–æ–ª–µ–∑–Ω—ã–º* –±—É–¥–µ—Ç –≤–∞—à –º–∞—Ç–µ—Ä–∏–∞–ª\\.\n\n"
            "‚úÖ *–î–æ–ø—É—Å—Ç–∏–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:*\n"
            "‚Ä¢ –ø–∏–∞—Ä\\-—á–∞—Ç—ã\n"
            "‚Ä¢ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∏–ª–∏ –æ—Ç–∫—Ä—ã—Ç—ã–µ –≥—Ä—É–ø–ø—ã\n"
            "‚Ä¢ –æ–±–ª–∞—á–Ω—ã–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ —Å –ø–æ–ª–µ–∑–Ω—ã–º –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º –∏ –¥—Ä\\.\n\n"
            "‚ö†Ô∏è *–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø–∞–º–∞ –∏–ª–∏ –º—É—Å–æ—Ä–∞ –ø—Ä–∏–≤–µ–¥—ë—Ç –∫ –±–∞–Ω—É –≤–æ –≤—Å–µ—Ö –Ω–∞—à–∏—Ö –ø—Ä–æ–µ–∫—Ç–∞—Ö\\.*\n\n"
            "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞—è–≤–∫—É –∏ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π\\."
        )
    else:
        return (
            "ü§ñ This bot is created for *free trading*\\.\n\n"
            "If you have a *useful digital item* or a *Telegram group*, you can submit it to us here\\.\n\n"
            "If your submission is *working and of good quality*, you will receive *in\\-bot currency*\\. The amount depends on how *valuable and useful* your item is\\.\n\n"
            "‚úÖ *Acceptable formats:*\n"
            "‚Ä¢ promotion chats\n"
            "‚Ä¢ private or public groups\n"
            "‚Ä¢ cloud storage with useful content, etc\\.\n\n"
            "‚ö†Ô∏è *Sending spam or trash content will lead to a ban from all our projects\\.*\n\n"
            "Click the button below to submit your request and read the instructions\\."
        )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_data = db.get_user(user.id)

    if user_data and user_data['lang']:
        lang = user_data['lang']
        
        text = get_main_menu_text(lang)
        button_text = "üöÄ –ù–∞—á–∞—Ç—å —Ç—Ä–µ–π–¥" if lang == 'ru' else "üöÄ Start Trade"
        
        keyboard = [[InlineKeyboardButton(button_text, callback_data='start_trade')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if update.message:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='MarkdownV2')
        else:
            try:
                await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='MarkdownV2')
            except:
                await send_message_safe(context.bot, user.id, text, reply_markup=reply_markup, parse_mode='MarkdownV2')
        
        return TRADE

    keyboard = [
        [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data='lang_ru')],
        [InlineKeyboardButton("üá¨üáß English", callback_data='lang_en')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    text = "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Choose language"
    if update.message:
        msg = await update.message.reply_text(text, reply_markup=reply_markup)
    else:
        try:
            msg = await update.callback_query.edit_message_text(text, reply_markup=reply_markup)
        except:
            msg = await send_message_safe(context.bot, user.id, text, reply_markup=reply_markup)

    context.user_data['lang_message_id'] = msg.message_id
    return LANGUAGE

async def language(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    
    user = query.from_user
    lang = query.data.split('_')[1]
    
    db.add_user(
        user_id=user.id,
        username=user.username,
        first_name=user.first_name,
        last_name=user.last_name,
        lang=lang
    )
    
    text = get_main_menu_text(lang)
    button_text = "üöÄ –ù–∞—á–∞—Ç—å —Ç—Ä–µ–π–¥" if lang == 'ru' else "üöÄ Start Trade"
    
    keyboard = [[InlineKeyboardButton(button_text, callback_data='start_trade')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    try:
        await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode='MarkdownV2')
    except Exception as e:
        logger.error(f"Error editing message: {e}")
        await send_message_safe(
            context.bot, 
            user.id, 
            text, 
            reply_markup=reply_markup, 
            parse_mode='MarkdownV2'
        )
    
    return TRADE

async def start_trade(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    user_data = db.get_user(query.from_user.id)
    lang = user_data['lang']
    
    text = "üìù –ü—Ä–∏—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\nüîó –°—Å—ã–ª–∫–∞\nüÜî –í–∞—à ID –≤ Summer –±–æ—Ç–µ" if lang == 'ru' else "üìù Send message in format:\nüîó Link\nüÜî Your Summer bot ID"
    await query.edit_message_text(text=text)
    return TRADE

async def handle_trade_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    user_data = db.get_user(user.id)
    lang = user_data['lang']
    message_text = update.message.text

    lines = message_text.split('\n')
    if len(lines) != 2 or not lines[0].strip() or not lines[1].strip():
        error_text = (
            "‚ùå *–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.* –ü—Ä–∏—à–ª–∏—Ç–µ:\nüîó *–°—Å—ã–ª–∫–∞*\nüÜî *ID*"
            if lang == 'ru'
            else "‚ùå *Invalid format.* Send:\nüîó *Link*\nüÜî *ID*"
        )
        await update.message.reply_text(error_text, parse_mode="Markdown")
        return TRADE

    link = lines[0].strip()
    summer_id = lines[1].strip()
    request_id = db.add_request(user.id, link, summer_id)

    success_text = "‚úÖ *–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!*" if lang == 'ru' else "‚úÖ *Request submitted!*"
    await update.message.reply_text(success_text, parse_mode="Markdown")

    admin_text = (
        f"üì© *–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:* @{user.username if user.username else 'N/A'}\n"
        f"üîó *–°—Å—ã–ª–∫–∞:* `{link}`\n"
        f"üÜî *–ê–π–¥–∏:* `{summer_id}`"
    )

    keyboard = [
        [
            InlineKeyboardButton("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f'reject_{request_id}'),
            InlineKeyboardButton("‚úÖ –ü—Ä–∏–Ω—è—Ç—å", callback_data=f'accept_{request_id}')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    for admin_id in ADMIN_IDS:
        await send_message_safe(
            context.bot,
            admin_id,
            admin_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

    text = get_main_menu_text(lang)
    keyboard = [[
        InlineKeyboardButton(
            "üöÄ –ù–∞—á–∞—Ç—å —Ç—Ä–µ–π–¥" if lang == 'ru' else "üöÄ Start Trade",
            callback_data='start_trade'
        )
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(text, reply_markup=reply_markup, parse_mode="MarkdownV2")

    return TRADE

async def handle_request_decision(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    try:
        action, request_id = query.data.split('_', 1)
        request_id = int(request_id)
    except Exception as e:
        logger.error(f"Error parsing callback data: {e}")
        return
    
    request = db.get_request(request_id)
    if not request:
        logger.error(f"Request not found: {request_id}")
        return
        
    user_id = request['user_id']
    user_data = db.get_user(user_id)
    if not user_data:
        logger.error(f"User not found: {user_id}")
        return
        
    lang = user_data['lang']
    
    if action == 'accept':
        db.update_request_status(request_id, 'approved')
        user_text = "üéâ –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞!" if lang == 'ru' else "üéâ Request approved!"
        admin_text = f"‚úÖ –ó–∞—è–≤–∫–∞ {request_id} –æ–¥–æ–±—Ä–µ–Ω–∞"
    elif action == 'reject':
        db.update_request_status(request_id, 'rejected')
        user_text = "üòû –ó–∞—è–≤–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞." if lang == 'ru' else "üòû Request rejected."
        admin_text = f"‚ùå –ó–∞—è–≤–∫–∞ {request_id} –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞"
    else:
        logger.error(f"Unknown action: {action}")
        return
        
    await send_message_safe(context.bot, user_id, user_text)
    
    try:
        await query.edit_message_reply_markup(reply_markup=None)
        await query.message.reply_text(admin_text)
    except Exception as e:
        logger.error(f"Failed to update admin message: {e}")

async def admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("‚õî –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
        return ConversationHandler.END
    
    keyboard = [
        [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data='admin_stats')],
        [InlineKeyboardButton("üì® –ó–∞—è–≤–∫–∏", callback_data='admin_requests')],
        [InlineKeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data='admin_broadcast')],
        [InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏", callback_data='admin_check_blocks')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.message:
        await update.message.reply_text("üë®‚Äçüíª –ê–¥–º–∏–Ω –º–µ–Ω—é:", reply_markup=reply_markup)
    else:
        try:
            await update.callback_query.edit_message_text("üë®‚Äçüíª –ê–¥–º–∏–Ω –º–µ–Ω—é:", reply_markup=reply_markup)
        except:
            await send_message_safe(context.bot, user.id, "üë®‚Äçüíª –ê–¥–º–∏–Ω –º–µ–Ω—é:", reply_markup=reply_markup)
    
    return ADMIN_MAIN

async def admin_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    today, yesterday, total = db.get_stats()
    text = (
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n\n"
        f"ü§ñ –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}\n"
        f"üìÖ –°–µ–≥–æ–¥–Ω—è: {today}\n"
        f"üìÖ –í—á–µ—Ä–∞: {yesterday}"
    )
    
    keyboard = [
        [InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data='admin_stats_refresh')],
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='admin_back')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)

async def admin_requests(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    requests = db.get_pending_requests()
    text = "üì® –û–∂–∏–¥–∞—é—â–∏–µ –∑–∞—è–≤–∫–∏:\n"
    if not requests:
        text += "–ù–µ—Ç –∑–∞—è–≤–æ–∫"
    else:
        for req in requests:
            request_id, created_at = req['request_id'], req['created_at']
            date_str = datetime.strptime(created_at, '%Y-%m-%d %H:%M:%S').strftime('%d.%m.%Y %H:%M')
            text += f"\n/request_{request_id} - {date_str}"
    
    keyboard = [[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='admin_back')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)

async def admin_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    text = "üì¢ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:"
    keyboard = [
        [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='admin_back')],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data='admin_cancel_broadcast')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text=text, reply_markup=reply_markup)
    return ADMIN_BROADCAST

async def admin_broadcast_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message = update.message
    context.user_data['broadcast_message'] = message.text
    
    user_count = len(db.get_all_active_users())
    text = (
        f"üì¢ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏\n\n"
        f"–°–æ–æ–±—â–µ–Ω–∏–µ:\n{message.text}\n\n"
        f"–ë—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {user_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n\n"
        f"–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ?"
    )
    
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ –î–∞, –æ—Ç–ø—Ä–∞–≤–∏—Ç—å", callback_data='broadcast_confirm_yes'),
            InlineKeyboardButton("‚ùå –ù–µ—Ç, –æ—Ç–º–µ–Ω–∏—Ç—å", callback_data='broadcast_confirm_no')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await message.reply_text(text, reply_markup=reply_markup)
    return ADMIN_BROADCAST_CONFIRM

async def admin_broadcast_execute(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    if not BROADCAST_LOCK.acquire(blocking=False):
        await query.edit_message_text("‚è≥ –†–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...")
        return
    
    try:
        broadcast_text = context.user_data['broadcast_message']
        user_ids = db.get_all_active_users()
        total_users = len(user_ids)
        success = 0
        failed = 0
        blocked_users = []

        await query.edit_message_text(f"‚è≥ –ù–∞—á–∞—Ç–∞ —Ä–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è {total_users} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")

        for i, user_id in enumerate(user_ids):
            if i % 20 == 0 and i > 0:
                time.sleep(1)
            
            try:
                await context.bot.send_message(chat_id=user_id, text=broadcast_text)
                success += 1
            except Exception as e:
                if "bot was blocked by the user" in str(e).lower():
                    blocked_users.append(user_id)
                failed += 1

        if blocked_users:
            db.mark_blocked_users(blocked_users)

        db.add_broadcast_record(
            admin_id=query.from_user.id,
            message_text=broadcast_text,
            total_users=total_users,
            success_count=success,
            failed_count=failed
        )

        result_text = (
            f"üì¢ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—Å—ã–ª–∫–∏:\n"
            f"‚úÖ –£—Å–ø–µ—à–Ω–æ: {success}\n"
            f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å: {failed}\n"
            f"üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–≤—à–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(blocked_users)}"
        )
        
        keyboard = [[InlineKeyboardButton("üë®‚Äçüíª –í –º–µ–Ω—é", callback_data='admin_back')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(result_text, reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫–µ: {e}")
        await query.edit_message_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫–µ: {str(e)}")
    finally:
        BROADCAST_LOCK.release()
        return ADMIN_MAIN

async def admin_check_blocks(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text("‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–≤—à–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")
    
    user_ids = db.get_all_active_users()
    blocked_users = []
    
    for user_id in user_ids:
        try:
            await context.bot.send_chat_action(chat_id=user_id, action='typing')
        except Exception as e:
            if "bot was blocked by the user" in str(e).lower():
                blocked_users.append(user_id)
    
    if blocked_users:
        db.mark_blocked_users(blocked_users)
        text = f"üîç –ù–∞–π–¥–µ–Ω–æ {len(blocked_users)} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–≤—à–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
    else:
        text = "‚úÖ –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∞–∫—Ç–∏–≤–Ω—ã"
    
    keyboard = [[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='admin_back')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text, reply_markup=reply_markup)

async def admin_back(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    keyboard = [
        [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data='admin_stats')],
        [InlineKeyboardButton("üì® –ó–∞—è–≤–∫–∏", callback_data='admin_requests')],
        [InlineKeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data='admin_broadcast')],
        [InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏", callback_data='admin_check_blocks')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text="üë®‚Äçüíª –ê–¥–º–∏–Ω –º–µ–Ω—é:", reply_markup=reply_markup)
    return ADMIN_MAIN

async def admin_cancel_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    if 'broadcast_message' in context.user_data:
        del context.user_data['broadcast_message']
    
    keyboard = [
        [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data='admin_stats')],
        [InlineKeyboardButton("üì® –ó–∞—è–≤–∫–∏", callback_data='admin_requests')],
        [InlineKeyboardButton("üì¢ –†–∞—Å—Å—ã–ª–∫–∞", callback_data='admin_broadcast')],
        [InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏", callback_data='admin_check_blocks')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(text="üë®‚Äçüíª –ê–¥–º–∏–Ω –º–µ–Ω—é:", reply_markup=reply_markup)
    return ADMIN_MAIN

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text('‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.')
    return ConversationHandler.END

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error("Exception while handling an update:", exc_info=context.error)
    if update and update.effective_user:
        await send_message_safe(
            context.bot,
            update.effective_user.id,
            "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        )

def main() -> None:
    application = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            LANGUAGE: [CallbackQueryHandler(language, pattern='^lang_(ru|en)$')],
            TRADE: [
                CallbackQueryHandler(start_trade, pattern='^start_trade$'),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_trade_message)
            ],
            ADMIN_MAIN: [
                CallbackQueryHandler(admin_stats, pattern='^admin_stats$|^admin_stats_refresh$'),
                CallbackQueryHandler(admin_requests, pattern='^admin_requests$'),
                CallbackQueryHandler(admin_broadcast, pattern='^admin_broadcast$'),
                CallbackQueryHandler(admin_check_blocks, pattern='^admin_check_blocks$'),
                CallbackQueryHandler(admin_back, pattern='^admin_back$')
            ],
            ADMIN_BROADCAST: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, admin_broadcast_confirm),
                CallbackQueryHandler(admin_back, pattern='^admin_back$'),
                CallbackQueryHandler(admin_cancel_broadcast, pattern='^admin_cancel_broadcast$')
            ],
            ADMIN_BROADCAST_CONFIRM: [
                CallbackQueryHandler(admin_broadcast_execute, pattern='^broadcast_confirm_yes$'),
                CallbackQueryHandler(admin_back, pattern='^broadcast_confirm_no$|^admin_back$')
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )

    application.add_handler(conv_handler)
    application.add_handler(CommandHandler('admin', admin))
    application.add_handler(CallbackQueryHandler(handle_request_decision, pattern='^(accept|reject)_[0-9]+$'))
    application.add_error_handler(error_handler)
    
    application.run_polling()

if __name__ == '__main__':
    try:
        main()
    finally:
        db.close()
